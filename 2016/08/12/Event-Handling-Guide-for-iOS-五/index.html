<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Event Handling Guide for iOS(五) | SongYiTing</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Event Handling Guide for iOS(五)</h1><a id="logo" href="/.">SongYiTing</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Event Handling Guide for iOS(五)</h1><div class="post-meta">Aug 12, 2016<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/08/12/Event-Handling-Guide-for-iOS-五/" href="/2016/08/12/Event-Handling-Guide-for-iOS-五/#comments" class="ds-thread-count"></a><div class="post-content"><p>基本概念:</p>
<ul>
<li>加速计: 又称加速度计，测量设备运动的加速度。</li>
<li>加速度: 矢量，描绘速度的方向和大小变化的快慢。</li>
<li>陀螺仪: 感测与维持方向的装置。</li>
</ul>
<blockquote>
<p>原文: <a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/motion_event_basics/motion_event_basics.html#//apple_ref/doc/uid/TP40009541-CH6-SW14" target="_blank" rel="external">Motion Event</a><br>声明: 由于本人水平有限，翻译定有不当甚至错误之处，如有发现还望指出。</p>
</blockquote>
<a id="more"></a>
<h1 id="Motion-Events"><a href="#Motion-Events" class="headerlink" title="Motion Events"></a>Motion Events</h1><p>当用户移动，摇晃，或倾斜设备时，产生motion事件。这些motion事件被设备硬件检测到，就是加速计和陀螺仪。</p>
<p>acclerometer事实上是由3个加速计组成，X，Y，Z坐标轴各有一个。每一个测量随着时间的推移以线性的速度变化。结合这三个加速计可以让你检测到设备的任何方向上的运动，以及获得设备的当前方向。虽然有3个加速计，在本文档的其余部分是指它们作为一个单一的实体。<b>gyroscope</b> 测量围绕3个轴的旋转速度。</p>
<p>所有的motion事件产生于同样的硬件。访问该硬件数据有几种不同的方式，这取决于您的应用程序的需求:</p>
<ul>
<li>如果你需要检测设备的大体方向，但是不必知道方向向量，用UIDevice类。看 <a href="#1">Getting the Current Device Orientation with UIDevice</a> 来获得更多的信息。</li>
<li>如果你想你的应用响应用户摇晃设备，你可以用UIKit框架中的motion-event handling methods来从传递的UIEvent对象中获得信息。看 <a href="#2">Detecting Shake-Motion Events with UIEvent</a> 来获得更多信息。</li>
<li>如果UIDevice和UIEvent类都不能满足需求的话，可能你希望用Core Motion框架来访问加速计，陀螺仪，以及设备运动类。看 <a href="#3">Capturing Device Movement with Core Motion</a> 来获得更多信息。</li>
</ul>
<p><a name="1" style="position: relative;top: -60px;">&nbsp;</a></p>
<h2 id="用UIDevice获得设备的当前方向"><a href="#用UIDevice获得设备的当前方向" class="headerlink" title="用UIDevice获得设备的当前方向"></a>用UIDevice获得设备的当前方向</h2><p>当你需要知道设备的大体方向，而不是精确的方向向量，用 <span class="sclKeyWord">UIDevice</span> 类的方法。用UIDevice很简单，不需要你自己计算方法向量。</p>
<p>在你获得当前方向前，调用 <span class="sclKeyWord">beginGeneratingDeviceOrientationNotifications</span> 方法，来告诉UIDevice类开启设备方向的通知，。这样会启动加速计硬件，为了节省电量加速计可能会被关闭。代码4-1在viewDidLoad方法中做了演示。</p>
<p>启用方向通知后，从UIDevice对象的 <span class="sclKeyWord">orientation property</span> 获得当前方向。如果你想得到设备方向改变的通知，注册接收 <span class="sclKeyWord">UIDeviceOrientationDidChangeNotification</span> 通知。设备方向用UIDeviceOrientation常量表示，指示设备是横屏模式，竖屏模式，屏幕朝上，还是屏幕朝下等等。这些常量指示设备的物理方向，并不一定符合你应用的用户界面方向。</p>
<p>当你不需要知道设备方向时，总是要调用UIDevice的 <span class="sclKeyWord">endGeneratingDeviceOrientationNotifications</span> 来禁用方向通知。这会给系统一个禁用加速计的机会，如果加速计不在别处使用的话，这样可以保留电池电量。</p>
<p>Listing 4-1 Responding to changes in device orientation<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	<span class="comment">// Request to turn on accelerometer and begin receiving accelerometer events</span></span><br><span class="line">	[[<span class="built_in">UIDevice</span> currentDevice] beginGeneratingDeviceOrientationNotifications];</span><br><span class="line">	[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(orientationChanged:) name:<span class="built_in">UIDeviceOrientationDidChangeNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)orientationChanged:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line"> 	<span class="comment">// Respond to changes in device orientation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear &#123;</span><br><span class="line"> 	<span class="comment">// Request to stop receiving accelerometer events and turn off accelerometer</span></span><br><span class="line"> 	[[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line"> 	[[<span class="built_in">UIDevice</span> currentDevice] endGeneratingDeviceOrientationNotifications];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>响应设备方向变换的另一个例子，看 <a href="https://developer.apple.com/library/ios/samplecode/AlternateViews/Introduction/Intro.html#//apple_ref/doc/uid/DTS40008755" target="_blank" rel="external">Alternate Views</a> 例子代码。</p>
<p><a name="2" style="position: relative;top: -60px;">&nbsp;</a></p>
<h2 id="用UIEvent检测Shake-Motion事件"><a href="#用UIEvent检测Shake-Motion事件" class="headerlink" title="用UIEvent检测Shake-Motion事件"></a>用UIEvent检测Shake-Motion事件</h2><p>当用户摇晃设备时，iOS评估加速计数据。如果数据满足一定的标准，iOS解释摇晃手势，并创建 <span class="sclKeyWord">UIEvent</span> 对象来表示它。然后它发送event对象给当前活跃的应用来处理。注意，你的应用可以同时响应shake-motion事件和设备方向的改变。</p>
<p>运动事件要比触摸事件简单。当运动开始和停止时，系统会通知应用，而不是每一次单独的运动都会通知。而且，motion事件只包括一个事件类型( <span class="sclKeyWord">UIEventTypeMotion</span> ),事件子类型( <span class="sclKeyWord">UIEventSubtypeMotionShake</span> )，以及一个时间戳。</p>
<h3 id="为运动事件指派第一响应者"><a href="#为运动事件指派第一响应者" class="headerlink" title="为运动事件指派第一响应者"></a>为运动事件指派第一响应者</h3><p>为了接收motion事件，指派一个响应者对象作为第一响应者。这是你想要处理运动事件的响应者对象。代码4-2展示了一个responder如何让自己成为第一响应者。</p>
<p>Listing 4-2 Becoming first responder<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">	[<span class="keyword">self</span> becomeFirstResponder];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Motion事件使用响应者链来找到处理事件的对象。当用户开始摇晃设备时，iOS给第一响应者发送第一个运动事件。如果第一响应者不能处理事件，它沿着响应者链向上传递。看 <span class="sclKeyWord">The Responder Chain Follows a Specific Delivery Path</span> 获得更多信息。如果shaking-motion事件沿着响应者链被传递到了window而没有被处理，并且UIApplication的 <span class="sclKeyWord">applicationSupportsShakeToEdit</span> 属性为<span style="color: blue">YES</span>(默认)，iOS显示一个带撤销和重做命令的sheet。</p>
<h3 id="实现Motion-Handling方法"><a href="#实现Motion-Handling方法" class="headerlink" title="实现Motion-Handling方法"></a>实现Motion-Handling方法</h3><p>有三个Motion-Handling方法， <span class="sclKeyWord">motionBegan:withEvent:</span> ,  <span class="sclKeyWord">motionEnded:withEvent:</span> , and <span class="sclKeyWord">motionCancelled:withEvent:</span> 。处理运动事件，你必须实现motionBegan:withEvent:或motionEnded:withEvent:方法，有时两者都会实现。一个响应者也应该实现motionCancelled:withEvent:方法来响应iOS取消一个运动事件。如果摇晃运动被打断或者iOS测定了运动是无效的－例如摇晃持续了太长时间，事件就会被取消。</p>
<p>代码4-3是从示例工程 <span class="sclKeyWord">GLPaint</span> 中提取的。在那个应用中，用户在屏幕上绘制，并且晃动设备来擦除绘画。代码在motionEnded:withEvent:中检测是否是摇晃，如果是的话，发送通知来执行shake-to-erase功能。</p>
<p>Listing 4-3 Handling a motion event<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">	<span class="keyword">if</span> (motion == <span class="built_in">UIEventSubtypeMotionShake</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//User was shaking the device.Post a notification named "shake."</span></span><br><span class="line">		[[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"shake"</span> object:<span class="keyword">self</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意: 除了简单，另一个使用shake-motion事件，而不是Core Motion的原因是，当你测试和调试你的应用时可以在iOS模拟器上模拟shake-motion事件。更多关于iOS Simulator的信息，请看 <a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/iOS_Simulator_Guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012848" target="_blank" rel="external">Simulator User Guide</a> 。</p>
<p><br></p>
<h2 id="设置和检查运动事件所需的硬件功能"><a href="#设置和检查运动事件所需的硬件功能" class="headerlink" title="设置和检查运动事件所需的硬件功能"></a>设置和检查运动事件所需的硬件功能</h2><p>在你的应用可以访问设备相关的功能之前，如加速计数据，你必须为你的应用添加必须的功能列表。具体来说，给应用的Info.plist文件加入keys。在运行的时候，只有设备有这些必须的功能，iOS才会启动你的应用。例如，如果你的应用依赖陀螺仪数据，列出陀螺仪，那么如果设备没有一个陀螺仪则应用不会启动。App Store也会使用这个list来通知用户，避免用户下载他们不能运行的apps。</p>
<p>声明你的应用需要的功能，使用 <span class="sclKeyWord">adding keys to your app’s propery list</span> 。有两个UIRequiredDeviceCapabilities keys，基于硬件的源:</p>
<ul>
<li>accelerometer</li>
<li>gyroscope</li>
</ul>
<p>注意: 如果你的应用只检测设备方向的改变，不必包括accelerometer key。</p>
<p>你可以用数组或者字典来指定key-values。如果你用数组的话，在数组中列出每一个需要的功能key。如果你用字典的话，为字典中的每一个需要的key指定一个Boolean值。这两种方法，都不需要列出不需要的功能的key。更多信息，看 <span class="sclKeyWord">UIRequiredDeviceCapabilities</span> 。</p>
<p>如果你的应用使用陀螺仪数据的功能对用户体验来说不是不可或缺的，你可能也想让没有陀螺仪设备的用户下载应用。如果你没有指定陀螺仪为必须的硬件功能，但是仍然有请求陀螺仪数据的代码，你需要在运行的时候检查陀螺仪是否可用。通过 <span class="sclKeyWord">CMMotionManager</span> 类的 <span class="sclKeyWord">gyroAvailiable</span> 属性来检查。</p>
<p><a name="3" style="position: relative;top: -60px;">&nbsp;</a></p>
<h2 id="用Core-Motion捕获设备运动"><a href="#用Core-Motion捕获设备运动" class="headerlink" title="用Core Motion捕获设备运动"></a>用Core Motion捕获设备运动</h2><p>Core Motion框架主要负责访问原始的加速计和陀螺仪数据，并将数据传递给一个应用来处理。Core Motion用独特的算法来处理收集的原始数据，以便它可以呈现更紧致的信息。这个处理发生在框架自己的线程上。</p>
<p>Core Motion与UIKit是截然不同的。它不与 <span class="sclKeyWord">UIEvent</span> 模型连接，并且也不使用响应者链。代替的，Core Motion简单的将运动事件直接传递给请求它们的apps。</p>
<p>Core Motion事件由三个数据对象表示，每一个数据对象包含一个或多个测量:</p>
<ul>
<li><span class="sclKeyWord">CMAccelerometerData</span> 对象捕获沿空间轴的加速度。</li>
<li><span class="sclKeyWord">CMGyroData</span> 对象捕获围绕三个空间轴的旋转速度。</li>
<li><span class="sclKeyWord">CMDeviceMotion</span> 对象封装了几个不同的测量，包括高度，旋转速度和加速度的更加有用的测量。</li>
</ul>
<p><span class="sclKeyWord">CMMotionManager</span> 类是Core Motion的中心接入点。创建一个该类的实例，指定一个更新间隔，更新开始请求，处理运动事件，并将他们传递。一个应用应该只创建一个<span class="sclKeyWord">CMMotionManager</span> 类的实例。多个该类的实例会影响一个应用从加速计和陀螺仪接收数据的速度。</p>
<p>所有的Core Motion数据封装类都是 <span class="sclKeyWord">CMLogItem</span> 的子类，CMLogItem定义了一个时间戳，以便运动数据可以被time标记并且纪录到一个文件中。一个应用的运动事件可以与之前的运动事件比较时间戳，确定两个事件真实的更新间隔。</p>
<p>对于每一个描述的运动数据类型， <span class="sclKeyWord">CMMotionManager</span> 类提供了两个获得运动数据的途径:</p>
<ul>
<li><b>Pull.</b> 一个应用请求更新开始，并定期的取样最新的运动数据测量。</li>
<li><b>Push.</b> 一个应用指定更新周期，并实现一个处理数据的block。然后，请求更新启动，并通过Core Motion的操作队列和block。Core Motion向block传递每一个更新，block在那个操作队列中作为一个任务执行。</li>
</ul>
<p>Pull是大多数apps，尤其是游戏的推荐途径。它通常更有效而且需要较少的代码。Push适合数据收集的应用以及不能丢失任何一个样品测量类似应用。这两种方式都是线程安全的；用push，你的block在操作队列的线程中执行，而用pull,Core Motion从不会打断你的线程。</p>
<p>重要: 用Core Motion，你必须在设备上测试和调试应用。iOS模拟器不支持加速计和陀螺仪数据。</p>
<p>当应用处理完必要的数据时，尽快停掉运动更新。这样的话，Core Motion可以关闭运动传感器，节省电量。</p>
<h3 id="选择运动事件更新周期"><a href="#选择运动事件更新周期" class="headerlink" title="选择运动事件更新周期"></a>选择运动事件更新周期</h3><p>当你用Core Motion请求运动数据时，你指定一个更新间隔。你应该选择满足你应用的最大间隔。间隔越大，就有越少的事件传递给你的应用，这会提高电池寿命。表4-1里列出了一些常用更新频率，并解释了你可以用那个频率生成的数据做什么。很少有应用需要acceleration事件每秒100次的传递。</p>
<p><img src="/img/EHG5/01.png" alt=""></p>
<p>你可以将间隔设置为10毫秒那么小，这会以100Hz的更新速率响应，但是大多是应用有一个较大的间隔就足够用了。</p>
<h3 id="使用Core-Motion处理加速计事件"><a href="#使用Core-Motion处理加速计事件" class="headerlink" title="使用Core Motion处理加速计事件"></a>使用Core Motion处理加速计事件</h3><p>加速计测量随着时间推移3个轴的速度，如图4-1所示。用Core Motion,每一个运动被捕获在 <span class="sclKeyWord">CMAccelerometerData</span> 对象中，CMAccelerometerData封装了一个CMAcceleration类型的结构体。</p>
<p><img src="/img/EHG5/02.png" alt=""></p>
<p>为了开始接收并处理加速计数据，创建一个CMMotionManager类的实例，并调用以下方法之一:</p>
<ul>
<li><p><span class="sclKeyWord">startAccelerometerUpdates</span> -pull方式<br>  在调用该方法后，Core Motion不断的使用加速计活动的最新测量更新CMMotionManager的 <span class="sclKeyWord">accelerometerdata</span> 属性。然后，你定期的取样该属性，在游戏中通常是一个呈现循环。如果你采用这种轮询方式，设置更新间隔属性( <span class="sclKeyWord">accelerometerUpdate</span> )为最大时间间隔m,Core Motion以此执行更新。</p>
</li>
<li><p><span class="sclKeyWord">startAccelerometerUpdatesToQueue:withHandler:</span> -push方式<br>  在调用该方法前，给 <span class="sclKeyWord">accelerometerUpdateInterval</span> 属性赋一个更新间隔，创建一个 <span class="sclKeyWord">NSOperationQueue实例</span> 实例，实现 <span class="sclKeyWord">CMAccelerometerHandler</span> 类型的block来处理加速计的更新。然后，在motion manager对象上调用 <span class="sclKeyWord">startAccelerometerUpdatesToQueue:withHandler:</span> 方法，传递操作队列和block。以指定的更新间隔，Core Motion传递最新的加速计活动样本给block,该block作为任务在队列中执行。</p>
<p>  代码4-4 阐明了这种方式。</p>
</li>
</ul>
<p>代码4-4是从 <span class="sclKeyType">MotionGraphs</span> 示例项目中提取的，在那你可以细查更多的环境上下文。在该应用中，用户移动滑块来指定一个更新间隔。startUpdatesSWithSliderValue:方法用滑块值来计算心的更新间隔。然后，创建一个CMMotionManager类的实例，检查确保设备有一个加速计，并给motion manager赋一个新的更新间隔。该应用使用push方式接收加速计数据并在图上绘制。注意，它在stopUpdates方法中停止加速计更新。</p>
<p>代码4-4 在MotionGraphs中访问加速计数据<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> accelerometerMin = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startUpdatesWithSliderValue:(<span class="keyword">int</span>)sliderValue &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Determine the update interval</span></span><br><span class="line">     <span class="built_in">NSTimeInterval</span> delta = <span class="number">0.005</span>;</span><br><span class="line">     <span class="built_in">NSTimeInterval</span> updateInterval = accelerometerMin + delta * sliderValue;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Create a CMMotionManager</span></span><br><span class="line">     CMMotionManager *mManager = [(APLAppDelegate *)[[<span class="built_in">UIApplication</span> sharedApplication] delegate] sharedManager];</span><br><span class="line">     APLAccelerometerGraphViewController * __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Check whether the accelerometer is available</span></span><br><span class="line">     <span class="keyword">if</span> ([mManager isAccelerometerAvailable] == <span class="literal">YES</span>) &#123;</span><br><span class="line">          <span class="comment">// Assign the update interval to the motion manager</span></span><br><span class="line">          [mManager setAccelerometerUpdateInterval:updateInterval];</span><br><span class="line">          [mManager startAccelerometerUpdatesToQueue:[<span class="built_in">NSOperationQueue</span> mainQueue] withHandler:^(CMAccelerometerData *accelerometerData, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">               [weakSelf.graphView addX:accelerometerData.acceleration.x y:accelerometerData.acceleration.y z:accelerometerData.acceleration.z];</span><br><span class="line">               [weakSelf setLabelValueX:accelerometerData.acceleration.x y:accelerometerData.acceleration.y z:accelerometerData.acceleration.z];</span><br><span class="line">    	 &#125;];</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">self</span>.updateIntervalLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%f"</span>, updateInterval];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopUpdates &#123;</span><br><span class="line"> 	CMMotionManager *mManager = [(APLAppDelegate *)[[<span class="built_in">UIApplication</span> sharedApplication] delegate] 	sharedManager];</span><br><span class="line"> 	<span class="keyword">if</span> ([mManager isAccelerometerActive] == <span class="literal">YES</span>) &#123;</span><br><span class="line">   	   [mManager stopAccelerometerUpdates];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="处理旋转速度数据"><a href="#处理旋转速度数据" class="headerlink" title="处理旋转速度数据"></a>处理旋转速度数据</h3><p>一个陀螺仪测量设备沿着三个坐标的旋转速度，如图4-2所示。</p>
<p><img src="/img/EHG5/03.png" alt=""></p>
<p>每次你请求陀螺仪更新时，Core Motion有一个旋转速度的偏差估计并在 <span class="sclKeyType">CMGyroData</span> 对象中返回信息。CMGyroData有一个 <span class="sclKeyWord">rotationRate</span> 属性，该属性存储一个 <span class="sclKeyWord">CMRotationRate</span> 结构体，其捕获三个轴的旋转速度，以弧度每秒的单位。注意，由CMGyroData对象测量的旋转速度是有偏差的。用 <span class="sclKeyWord">CMDeviceMotion</span> 类你能获得更精确，无偏差的测量。看 <span class="sclKeyWord">Handling Processed Device Motin Data</span> 了解更多信息。</p>
<p>当分析旋转速度数据时 –具体来说，当分析 <span class="sclKeyWord">CMRotationMatrix</span> 结构体的字段 –跟随右手定则来决定旋转方向，如图4-2。用右手环绕着x轴，拇指朝向正x方向，正向旋转是朝向另外四个手指的提示方向。负向旋转是手指提示的相反方向。</p>
<p>为了开始接收并处理rotation-rate数据，创建一个 <span class="sclKeyWord">CMMotionManager</span> 类实例，并调用下列方法之一:</p>
<ul>
<li><p><span class="sclKeyWord">startGyroUpdates</span> –pull方式<br>  在调用该方法后，Core Motion不断的用最新的陀螺仪运动测量来更新CMMotionManager属性。然后，你定期的取样这些属性。如果你采用轮询方式，设置更新间隔属性( <span class="sclKeyWord">gyroUpdateInterval</span> 为最大间隔，Core Motion以此来执行更新。</p>
</li>
<li><p><span>startGyroUpdatesToQueue:withHandler:</span> –push方式<br>  调用该方法之前，给 <span class="sclKeyWord">gyroUpdateInterval</span> 赋一个更新间隔，创建一个 <span class="sclKeyWord">NSOperationQueue</span>实例，并实现 <span class="sclKeyWord">CMGyroHandler</span>类型block来处理陀螺仪更新。然后，在motion-manager对象上调用 <span class="sclKeyWord">startGyroUpdatesToQueue:withHandler:</span>方法，传递操作队列和block。以指定的更新间隔，Core Motion传递陀螺仪活动的最近样本给block，block作为一个任务在队列中执行。</p>
<p>  代码4-5阐明了这种方式。</p>
</li>
</ul>
<p>代码4-5也是从 <span class="sclKeyWord">MotionGraphs</span> 示例代码中提取的，并几乎和代码4-4一样。该应用使用push方式接收陀螺仪数据以便在屏幕上绘制数据。</p>
<p>代码4-5 在MotionGraphs中访问陀螺仪数据<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> gyroMin = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startUpdatesWithSliderValue:(<span class="keyword">int</span>)sliderValue &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Determine the update interval</span></span><br><span class="line">	<span class="built_in">NSTimeInterval</span> delta = <span class="number">0.005</span>;</span><br><span class="line">	<span class="built_in">NSTimeInterval</span> updateInterval = gyroMin + delta * sliderValue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a CMMotionManager</span></span><br><span class="line">	CMMotionManager *mManager = [(APLAppDelegate *)][<span class="built_in">UIApplication</span> sharedApplication] delegate] sharedmanager];</span><br><span class="line">	APLGyroGraphViewController * __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check Whether the gyroscope is avialable</span></span><br><span class="line">	<span class="keyword">if</span> ([mManager isGyroAvailable] == <span class="literal">YES</span>) &#123;</span><br><span class="line">		<span class="comment">// Assign the update interval to the motion manager</span></span><br><span class="line">		[mManager startGyroUpdatesToQueue:[<span class="built_in">NSOperationQueue</span> mainQueue] withHandler:^(CMGyroData *gyroData, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">			[weakSelf.graphView addX:gyroData.rotationRate.x y:gyroData.rotationRate.y z:gyroData.rotationRate.z];</span><br><span class="line">			[weakSelf setLabelValueX:gyroData.rotationRate.x y:gyroData.rotationRate.y z:gyroData.rotationRate.z];</span><br><span class="line">		&#125;];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">self</span>.updateIntervalLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%f"</span>, updateInterval];</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopUpdates &#123;</span><br><span class="line">	CMMotionManager *mManager = [(APLAppDelegate *)[[<span class="built_in">UIApplication</span> sharedApplication] delegate] sharedManager];</span><br><span class="line">	<span class="keyword">if</span> ([mManager isGyroActive] == <span class="literal">YES</span>) &#123;</span><br><span class="line">		[mManager stopGyroUpdates];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="处理经过Device-Motion处理过的数据"><a href="#处理经过Device-Motion处理过的数据" class="headerlink" title="处理经过Device Motion处理过的数据"></a>处理经过Device Motion处理过的数据</h3><p>如果设备既有加速计又有陀螺仪，Core Motion提供一个device-motion服务，它处理来自这两个传感器的原始运动数据。device motion使用传感器融合算法来提炼原始数据并产生用于设备方向，无偏差旋转率，设备的重力方向，以及用户产生的加速度信息。一个 <span class="sclKeyWord">CMDeviceMotion</span> 类的实例封装了这些数据。另外，你不必过虑加速度数据，因为device motion分离重力和用户加速度。</p>
<p>你可以通过CMDeviceMotion对象的 <span class="sclKeyWord">attitude</span> 属性访问姿态数据，它封装了一个CMAttitude对象。每一个 <span class="sclKeyWord">CMAttitude</span> 类的实例封装了attitude的三个数学表示:</p>
<ul>
<li>一个四元组</li>
<li>一个旋转矩阵</li>
<li>三个欧拉角(roll,pitch,and yaw)</li>
</ul>
<p>为了开始接收并处理device-motion更新，创建一个 <span class="sclKeyWord">CMMotionManager</span> 类实例并调用以下两个方法之一:</p>
<ul>
<li><span class="sclKeyWord">startDeviceMotionUpdates</span> –pull方式<br>  调用该方法后，Core Motion不断的用加速计和陀螺仪活动的最新提炼的测量更新CMMotionManager的 <span class="sclKeyWord">deviceMotion</span> 属性，封装在 <span class="sclKeyWord">CMDeviceMotion</span>对象中。然后，你定期的取样该属性。如果你采用轮询方式，设置更新间隔属性( <span class="sclKeyWord">deviceMotionUpdateInterval</span> )为最大的间隔，Core Motion以此来执行更新。<br>  代码4-6说明了该方式</li>
</ul>
<ul>
<li><span class="sclKeyWord">startDeviceMotionUpdatesToQueue:withHandler:</span> –push方式<br>  调用该方法前，为 <span class="sclKeyWord">deviceMotionUpdateInterval</span> 属性赋值一个更新间隔，创建一个 <span class="sclKeyWord">NSOperationQueue</span> 实例，并实现 <span class="sclKeyWord">CMDeviceMotionHandler</span> 类型的block来处理加速计的更新。然后，调用 <span class="sclKeyWord">startDeviceMotionUpdatesToQueue:withHandler:</span> 方法，传递操作队列和block。以指定的更新间隔，Core Motion向block传递结合了加速计和陀螺仪运动的最新样本，由 <span class="sclKeyWord">CMDeviceMotion</span> 对象表示，block在该队列中作为任务执行。</li>
</ul>
<p>代码4-6使用 <a href="https://developer.apple.com/library/ios/samplecode/pARk/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011083" target="_blank" rel="external">pARk</a> 示例项目中的代码来解释说明如何开启和停止device motion更新。startDeviceMotion方法使用pull方式用一个reference frame开始设备更新。看 <a href="#4">Device Attitude and the Reference Frame</a> 来获得更多关于device motion reference frames的信息。</p>
<p>代码4-6 开启和停止device motion更新<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startDeviceMotion &#123;</span><br><span class="line">	<span class="comment">// Create a CMMotionManager</span></span><br><span class="line">	motionManager = [[CMMotionManager alloc] init];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tell CoreMotion to show the compass calibration HUD when required</span></span><br><span class="line">	<span class="comment">// to provide true north-referenced attitude</span></span><br><span class="line">	motionManager.showsDeviceMovementDisplay = <span class="literal">YES</span>;</span><br><span class="line">	motionManager.deviceMotionUpdateInterval = <span class="number">1.0</span> / <span class="number">60.0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Attitude that is referenced to true north</span></span><br><span class="line">	[motionManager startDeviceMotionUpdatesUsingReferenceFrame:CMAttitudeReferenceFrameXTrueNorthZVertical];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopDeviceMotion &#123;</span><br><span class="line">     [motionManager stopDeviceMotionUpdates];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a name="4" style="position: relative;top: -60px;">&nbsp;</a></p>
<h3 id="设备姿态和参考系"><a href="#设备姿态和参考系" class="headerlink" title="设备姿态和参考系"></a>设备姿态和参考系</h3><p>一个CMDeviceMotion对象包含设备的attitude信息，或空间上的方向。设备attitude总是被测量在相关的reference frame。当你的应用开始device-motion更新时，Core Motion 建立reference frame。然后， <span class="sclKeyWord">CMAttitude</span> 给设备当前的reference frame一个来自于最初的reference frame的旋转。</p>
<p>在Core Motion reference frame中，z轴总是垂直的，x和y轴与重力总是直角，这使得重力向量为[0,0,-1]。该向量也被称为gravity reference。如果你将来自于CMAttitude对象的旋转矩阵与gravity reference相乘，就可以得到在设备frame上的重力。或者，算术地:</p>
<p><img src="/img/EHG5/04.png" alt=""></p>
<p>你可以改变CMAttitude用的参考系。通过缓存包含reference frame的attitude对象并将它作为参数传递给 <span class="sclKeyWord">multiplyByInverseOfAttitude:</span> 。该attitude参数接收消息改变以便它可以呈现从传入的reference frame的attitude的转变。</p>
<p>大多数应用对设备姿态感兴趣。为了了解这可能是多么有用，考虑棒球游戏，用户旋转设备来挥舞。通常情况下，在球场的起点，棒球棒处在某个静止方向。之后，棒球棒基于设备姿态相对于球场开始时的改变呈现。代码4-7说明了你能怎样做这些。</p>
<p>代码4-7 在呈现之前获得姿态的改变<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>) startPitch &#123;</span><br><span class="line">	<span class="comment">// referenceAttitude is a property</span></span><br><span class="line">	<span class="keyword">self</span>.referenceAttitude = <span class="keyword">self</span>.motionManager.deviceMotion.attitude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawView &#123;</span><br><span class="line">    CMAttitude *currentAttitude = <span class="keyword">self</span>.motionManager.deviceMotion.attitude;</span><br><span class="line">    [currentAttitude multiplyByInverseOfAttitude: <span class="keyword">self</span>.referenceAttitude];</span><br><span class="line">    <span class="comment">// Render bat using currentAttitude</span></span><br><span class="line">    [<span class="keyword">self</span> updateModelsWithAttitude:currentAttitude];</span><br><span class="line">    [renderer render];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这该例子中， <span class="sclKeyWord">multiplyByInverseOfAttitude:</span> 方法返回之后，currentAttitude表示从referenceAttitude到最近采样的 <span class="sclKeyWord">CMAttitude</span> 实例的变化。</p>
<blockquote>
<p>相关资料:<br><a href="http://insaneguy.me/2015/03/25/rotation_matrix_and_quaternions/" target="_blank" rel="external">旋转矩阵，四元数，欧拉角roll pitch yaw</a><br><a href="https://segmentfault.com/a/1190000002400742" target="_blank" rel="external">CMDeviceMotion</a></p>
</blockquote>
</div><div class="tags"></div><div class="post-nav"><a href="/2016/08/25/假如你不够快乐-汪国真/" class="pre">假如你不够快乐</a><a href="/2016/08/09/Event-Handing-Guide-for-iOS-三/" class="next">Event Handing Guide for iOS(三)</a></div><div data-thread-key="2016/08/12/Event-Handling-Guide-for-iOS-五/" data-title="Event Handling Guide for iOS(五)" data-url="http://songyiting.com/2016/08/12/Event-Handling-Guide-for-iOS-五/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/08/12/Event-Handling-Guide-for-iOS-五/" data-title="Event Handling Guide for iOS(五)" data-url="http://songyiting.com/2016/08/12/Event-Handling-Guide-for-iOS-五/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://songyiting.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/swift/">swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像处理/">图像处理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/诗和远方/">诗和远方</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/05/11/自定义手势/">自定义手势</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/iOS设计模式之工厂方法/">iOS设计模式之工厂方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/iOS设计模式之单例/">iOS设计模式之单例</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/雨巷/">雨巷</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/29/iOS屏幕分辨率问题/">iOS屏幕分辨率问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/29/错误/">错误</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/29/OpenCV基础篇/">OpenCV基础篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/27/我和小鸟和铃铛/">我和小鸟和铃铛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/12/Grand-Central-Dispatch-GCD-简单入门/">Grand Central Dispatch(GCD)简单入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/10/凝视/">凝视</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">SongYiTing.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'宋一听'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?a66d7839ff74fc93bcc5b00912145f14## Your Baidu Analytics tracking id, e.g. 8006843039519956000";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>